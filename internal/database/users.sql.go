// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const addAdmin = `-- name: AddAdmin :one
INSERT INTO users(id,name,hashed_password,access_finance,access_timeregistration,administrator)
VALUES(
    gen_random_UUID(),
    $1,
    $2,
    TRUE,
    TRUE,
    TRUE
) 
RETURNING id, name, hashed_password, access_finance, access_timeregistration, administrator
`

type AddAdminParams struct {
	Name           string
	HashedPassword string
}

func (q *Queries) AddAdmin(ctx context.Context, arg AddAdminParams) (User, error) {
	row := q.db.QueryRowContext(ctx, addAdmin, arg.Name, arg.HashedPassword)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.HashedPassword,
		&i.AccessFinance,
		&i.AccessTimeregistration,
		&i.Administrator,
	)
	return i, err
}

const addUser = `-- name: AddUser :one
INSERT INTO users(id,name,hashed_password,access_finance,access_timeregistration,administrator)
VALUES(
    gen_random_UUID(),
    $1,
    $2,
    $3,
    $4,
    0
) 
RETURNING id, name, hashed_password, access_finance, access_timeregistration, administrator
`

type AddUserParams struct {
	Name                   string
	HashedPassword         string
	AccessFinance          bool
	AccessTimeregistration bool
}

func (q *Queries) AddUser(ctx context.Context, arg AddUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, addUser,
		arg.Name,
		arg.HashedPassword,
		arg.AccessFinance,
		arg.AccessTimeregistration,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.HashedPassword,
		&i.AccessFinance,
		&i.AccessTimeregistration,
		&i.Administrator,
	)
	return i, err
}

const checkOnAdministartor = `-- name: CheckOnAdministartor :many
SELECT id, name FROM users
WHERE administrator = TRUE
`

type CheckOnAdministartorRow struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) CheckOnAdministartor(ctx context.Context) ([]CheckOnAdministartorRow, error) {
	rows, err := q.db.QueryContext(ctx, checkOnAdministartor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckOnAdministartorRow
	for rows.Next() {
		var i CheckOnAdministartorRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createFirstAdministartor = `-- name: CreateFirstAdministartor :one
INSERT INTO users(id,name,hashed_password,access_finance,access_timeregistration,administrator)
VALUES(
    gen_random_UUID(),
    $1,
    $2,
    TRUE,
    TRUE,
    TRUE
) 
RETURNING id, name, hashed_password, access_finance, access_timeregistration, administrator
`

type CreateFirstAdministartorParams struct {
	Name           string
	HashedPassword string
}

func (q *Queries) CreateFirstAdministartor(ctx context.Context, arg CreateFirstAdministartorParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createFirstAdministartor, arg.Name, arg.HashedPassword)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.HashedPassword,
		&i.AccessFinance,
		&i.AccessTimeregistration,
		&i.Administrator,
	)
	return i, err
}

const getUserPermissions = `-- name: GetUserPermissions :one
SELECT access_finance, access_timeregistration, administrator FROM users
WHERE name = $1
`

type GetUserPermissionsRow struct {
	AccessFinance          bool
	AccessTimeregistration bool
	Administrator          bool
}

func (q *Queries) GetUserPermissions(ctx context.Context, name string) (GetUserPermissionsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserPermissions, name)
	var i GetUserPermissionsRow
	err := row.Scan(&i.AccessFinance, &i.AccessTimeregistration, &i.Administrator)
	return i, err
}

const login = `-- name: Login :one
SELECT name,hashed_password,id FROM users
WHERE name = $1
`

type LoginRow struct {
	Name           string
	HashedPassword string
	ID             uuid.UUID
}

func (q *Queries) Login(ctx context.Context, name string) (LoginRow, error) {
	row := q.db.QueryRowContext(ctx, login, name)
	var i LoginRow
	err := row.Scan(&i.Name, &i.HashedPassword, &i.ID)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET name = $1,
    hashed_password = $2,
    access_finance = $3,
    access_timeregistration = $4,
    administrator = $5
WHERE id = $6
RETURNING name, access_finance,access_timeregistration,administrator
`

type UpdateUserParams struct {
	Name                   string
	HashedPassword         string
	AccessFinance          bool
	AccessTimeregistration bool
	Administrator          bool
	ID                     uuid.UUID
}

type UpdateUserRow struct {
	Name                   string
	AccessFinance          bool
	AccessTimeregistration bool
	Administrator          bool
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Name,
		arg.HashedPassword,
		arg.AccessFinance,
		arg.AccessTimeregistration,
		arg.Administrator,
		arg.ID,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.Name,
		&i.AccessFinance,
		&i.AccessTimeregistration,
		&i.Administrator,
	)
	return i, err
}
